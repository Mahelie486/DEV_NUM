import numpy as np
import math
from scipy.constants import mu_0, pi

from src.coordinate_and_position import CoordinateSystem
from src.fields import VectorField


class BiotSavartEquationSolver:
    """
    A Biot–Savart law solver used to compute the resultant magnetic field B in 2D-space generated by a constant current
    field I (for example due to wires).
    """
    """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (x, y) → (I_x(x, y), I_y(x, y), I_z(x, y)), where I_x(x, y), I_y(x, y) and
            I_z(x, y) are the 3 components of the electric current vector at a given point (x, y) in space. Note that
            I_z = 0 is always True in our 2D world.
        delta_x : float
            Small discretization of the x-axis.
        delta_y : float
            Small discretization of the y-axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (x, y) → (B_x(x, y), B_y(x, y), B_z(x, y)), where B_x(x, y), B_y(x, y) and
            B_z(x, y) are the 3 components of the magnetic vector at a given point (x, y) in space. Note that
            B_x = B_y = 0 is always True in our 2D world.
        """
    # Version préliminaire manque méthode pour aller chercher distance du point avec el.courant
    def _solve_in_cartesian_coordinate(
    self,
    electric_current: VectorField,
    delta_x: float,
     delta_y: float
    ) -> VectorField:
        """nb, le courent est donné dans une liste du genre [[[I_x, I_y]]]
        pour mettons juste une position x, y, donc avec electric_current[pos_x][pos_y][0 ou 1 pour I_x et I_y]"""
        # extrait dimensions de matrice
        position, current = [], []
        position, current = np.array(position), np.array(current)
        
        dim_x, dim_y = 10, 10 # World_shape de chaque circuit
        # calcul pour amener champs en z, donc on init la pos
        magnetic_field = np.zeros((dim_x, dim_y, 10))
    
        # remplace intégration en couvrant espaces en bond de delta
        for i in range(dim_x):  # les delta x et y sont de 1 anyway
            for j in range(dim_y):
                current_x, current_y= electric_current[i][j][0], electric_current[i][j][1]  # À position i, j = x, y
                if current_x != 0 or current_y != 0:
                    print(current_x.shape)
                    # Besoin de list pour que ça fonctionne
                    position = np.array(position.tolist() + [[i, j, 0]])
                    current = np.array(current.tolist() + [[current_x, current_y, 0]])
                    # Fais une grosse liste plutot que liste de liste sur lequel le reste repose
                if [i, j, 0] not in position:  # tte les position ou il y a un courant, donc dist. de el. courant = 0
                    # distance (from all current elements?)
                    # besoin de matrice pour que fonctionne
                    distance = position - [i, j, 0]  # = direct un array de distance de tous element de courant d'un point, en [x, y]
                    r_norm = (np.linalg.norm(distance, axis=1))
                    # portion perpendiculaire(champs perpendiculaire au courant)
                    cross_part = np.cross(current, distance)[:, 2]
                    champs_bio = np.sum(mu_0 * cross_part/(4*pi*r_norm*3))
                    print(champs_bio)
                    # Calcul biot savard: sum de tout élément champs rpl int.

                    #Probleme 2
                    # magnetic_field[i][j][:, 2] = champs_bio # Ne fonctionne pas
                    # comme electric_current, mais avec une liste de 3 plutôt que 2
        return VectorField(magnetic_field)


    def _solve_in_polar_coordinate(
            self,
            electric_current: VectorField,
            delta_r: float,
            delta_theta: float
    ) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (r, θ) → (I_r(r, θ), I_θ(r, θ), I_z(r, θ)), where I_r(r, θ), I_θ(r, θ) and
            I_z(r, θ) are the 3 components of the electric current vector at a given point (r, θ) in space. Note that
            I_z = 0 is always True in our 2D world.
        delta_r : float
            Small discretization of the r-axis.
        delta_theta : float
            Small discretization of the θ-axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (r, θ) → (B_r(r, θ), B_θ(r, θ), B_z(r, θ)), where B_r(r, θ), B_θ(r, θ) and
            B_z(r, θ) are the 3 components of the magnetic vector at a given point (r, θ) in space. Note that
            B_r = B_θ = 0 is always True in our 2D world.
        
        B_r = 0
        B_θ = 0
        magnetic_field = np.array([B_r, B_θ])
        
        for i in range(self.nb_iterations):
            B_r += (mu_0*electric_current / 4*pi) * (delta_r*np.cos(delta_theta))/(delta_r**2 + delta_theta**2)
            B_θ += (mu_0*electric_current / 4*pi) * (np.sin(delta_theta))/(delta_r**2 + delta_theta**2)
        return VectorField(magnetic_field)
        """
        # On convertit les coordonnées polaires et les deltas en catésien
        # extrait dimensions de matrice
        position, current = [], []
        dim_r, dim_thet = electric_current.shape
        magnetic_field = np.zeros((dim_r, dim_thet))
        # remplace intégration en couvrant espaces en bond de delta
        for i in range(0, dim_r, delta_r):
            for j in range(0, dim_thet, delta_theta):
                current_r, current_theta = electric_current[i, j][0], electric_current[i, j][1]
                # current_x = electric_current[i, j][0]*math.cos(electric_current[i, j][1])
                # current_y = electric_current[i, j][0]*math.sin(electric_current[i, j][1])
                if current_r != 0 or current_theta != 0:
                    position.append((i, j))
                    current.append(i)
                if (i, j) not in position:  # 0 if in pos et initialized with 0s
                    # distance (from all current elements?)
                    r = np.array([4, 4])  # Besoin de faire diff the dist avec chaque élément de courant
                    r_norm = (np.linalg.norm(r, axis=1))
                    # portion perpendiculaire(champs perpendiculaire au courant)
                    cross_part = np.cross(current, r)
                    # Calcul biot savard: sum de tout élément champs rpl int.
                    magnetic_field[i, j] = [0, 0, np.sum(mu_0 * cross_part[:,2]/(4*pi*r_norm*3))]
        return VectorField(magnetic_field)
    def solve(
            self,
            electric_current: VectorField,
            coordinate_system: CoordinateSystem,
            delta_q1: float,
            delta_q2: float
    ) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ representing currents in the 2D world.
        coordinate_system : CoordinateSystem
            Coordinate system.
        delta_q1 : float
            Small discretization of the first axis.
        delta_q2 : float
            Small discretization of the second axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ representing the magnetic field in the 2D world.
        """
        if coordinate_system == CoordinateSystem.CARTESIAN:
            return self._solve_in_cartesian_coordinate(electric_current, delta_q1, delta_q2)
        elif coordinate_system == CoordinateSystem.POLAR:
            return self._solve_in_polar_coordinate(electric_current, delta_q1, delta_q2)
        else:
            raise NotImplementedError("Only the cartesian and polar coordinates solvers are implemented.")
