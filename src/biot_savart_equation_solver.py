import numpy as np

from scipy.constants import mu_0, pi

from src.coordinate_and_position import CoordinateSystem
from src.fields import VectorField


class BiotSavartEquationSolver:
    """
    A Biot–Savart law solver used to compute the resultant magnetic field B in 2D-space generated by a constant current
    field I (for example due to wires).
    """
    """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (x, y) → (I_x(x, y), I_y(x, y), I_z(x, y)), where I_x(x, y), I_y(x, y) and
            I_z(x, y) are the 3 components of the electric current vector at a given point (x, y) in space. Note that
            I_z = 0 is always True in our 2D world.
        delta_x : float
            Small discretization of the x-axis.
        delta_y : float
            Small discretization of the y-axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (x, y) → (B_x(x, y), B_y(x, y), B_z(x, y)), where B_x(x, y), B_y(x, y) and
            B_z(x, y) are the 3 components of the magnetic vector at a given point (x, y) in space. Note that
            B_x = B_y = 0 is always True in our 2D world.
        """

    def _solve_in_cartesian_coordinate(
    self,
    electric_current: VectorField,
    delta_x: float,
     delta_y: float
    ) -> VectorField:
        """
        Les delta x et y n'ont pas été utilié puisque ils sont de 1 pour tous les circuits.
        La fonction range parcours déjà automatiquement les position données en bond de 1.

        A.M.
        """

        position, current = np.array([]), np.array([])
        
        # Les dimensions de World_Shape sont directement utilisé
        dim_x, dim_y = 101, 101

        # on initialise une matrice 3D de 0 pour le champs magnétique
        magnetic_field = np.zeros((dim_x, dim_y, 3))

        # On isole les positions qui forment le contour du fils ainsi que le courant qui s'y trouve
        for i in range(dim_x):
            for j in range(dim_y):
                current_x, current_y= electric_current[i][j][0], electric_current[i][j][1]
                if current_x != 0 or current_y != 0:

                    # S'il y a en effet un courant à cette position, on l'inclus aux listes décrivant le contour
                    position = np.array(position.tolist() + [[i, j, 0]])
                    current = np.array(current.tolist() + [[current_x, current_y, 0]])

        # Trouver champs en tous points de l'espace
        for i in range(dim_x):
            for j in range(dim_y):
                current_x, current_y= electric_current[i][j][0], electric_current[i][j][1]

                # On vérifie que la position (i, j) n'est pas un élément de courant 
                if current_x == 0 and current_y == 0:

                    # Si pas un élément de courant, on trouve distance avec tous éléments de courants
                    distance = position - [i, j, 0]
                    r_norm = (np.linalg.norm(distance, axis=1))
                    cross_part = np.cross(current, distance)[:, 2]
                    
                    # Somme du champs magnétique causé par tous éléments de courants au point (i, j)
                    champs_bio = np.sum(mu_0 * cross_part/(4*pi*r_norm**3))

                    # Intégration du champs magnétique au point (i, j) à la matrice avec tous les points de l'espace
                    magnetic_field[i][j][2] = champs_bio
        return VectorField(magnetic_field)


    def _solve_in_polar_coordinate(
            self,
            electric_current: VectorField,
            delta_r: float,
            delta_theta: float
    ) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (r, θ) → (I_r(r, θ), I_θ(r, θ), I_z(r, θ)), where I_r(r, θ), I_θ(r, θ) and
            I_z(r, θ) are the 3 components of the electric current vector at a given point (r, θ) in space. Note that
            I_z = 0 is always True in our 2D world.
        delta_r : float
            Small discretization of the r-axis.
        delta_theta : float
            Small discretization of the θ-axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (r, θ) → (B_r(r, θ), B_θ(r, θ), B_z(r, θ)), where B_r(r, θ), B_θ(r, θ) and
            B_z(r, θ) are the 3 components of the magnetic vector at a given point (r, θ) in space. Note that
            B_r = B_θ = 0 is always True in our 2D world.
        """
        position, current = np.array([]), np.array([])

        # Nb. Les dimension de World Shape ont été ajouté manuellement
        dim_r, dim_theta = 101, 101

        # on initialise une matrice 3D de 0 pour le champs magnétique
        magnetic_field = np.zeros((dim_r, dim_theta, 3))
    
        # On isole les positions qui formest le contour du fils ainsi que le courant qui s'y trouve
        for i in range(dim_r):
            for j in range(dim_theta):
                current_r, current_theta= electric_current[i][j][0], electric_current[i][j][1]
                if current_r != 0 or current_theta != 0:
                    position = np.array(position.tolist() + [[i, j, 0]])
                    current = np.array(current.tolist() + [[current_r, current_theta]])

        # Trouver champs en tous points de l'espace
        for i in range(dim_r):
            for j in range(dim_theta):

                # Vérifier qu'il n'y a pas de courant à la position
                current_r, current_theta= electric_current[i][j][0], electric_current[i][j][1]
                if current_r == 0 and current_theta == 0:

                    # Distance entre position actuelle et tous les éléments de courants
                    r_1 = i
                    r_2 = position[:, 0]
                    diff_theta = j - position[:, 1]
                    distance_sca = np.sqrt(r_1**2 + r_2**2 - 2*r_1*r_2*np.cos(diff_theta))

                    # Calcul du champs avec Biot-Savard avec le cross product du courant et vecteur r
                    # en tout point puis la somme de toute les contributions en un point
                    dist_vect = np.vstack((distance_sca, diff_theta))
                    cross_part = np.cross(current, np.transpose(dist_vect))
                    champs_bio = np.sum(mu_0 * cross_part/(4*pi*4**3))
    
                    # Substitution du champs à chaque point (i, j) dans la matrice de tout l'espace
                    magnetic_field[i][j][2] = champs_bio

        return VectorField(magnetic_field)


    def solve(
            self,
            electric_current: VectorField,
            coordinate_system: CoordinateSystem,
            delta_q1: float,
            delta_q2: float
    ) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ representing currents in the 2D world.
        coordinate_system : CoordinateSystem
            Coordinate system.
        delta_q1 : float
            Small discretization of the first axis.
        delta_q2 : float
            Small discretization of the second axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ representing the magnetic field in the 2D world.
        """
        if coordinate_system == CoordinateSystem.CARTESIAN:
            return self._solve_in_cartesian_coordinate(electric_current, delta_q1, delta_q2)
        elif coordinate_system == CoordinateSystem.POLAR:
            return self._solve_in_polar_coordinate(electric_current, delta_q1, delta_q2)
        else:
            raise NotImplementedError("Only the cartesian and polar coordinates solvers are implemented.")
